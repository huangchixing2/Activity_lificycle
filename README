活动的生命周期
1 返回栈： 先进后出。每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置，而每当我们按
           下back键或者调用finish（）方法去销毁一个活动时，处于栈顶的活动会出栈，这时，前一个入栈的
           活动就会重新处于栈顶位置。系统总是会显示处于栈顶的活动给用户。

2 活动的状态：
       1）运行状态：当一个活动位于返回栈的栈顶时处于运行状态。系统最不愿意回收的就是处于运行状态的活动。

       2）暂停状态：当一个活动不再处于栈顶位置，但仍然可见时，这时活动进入暂停状态。处于暂停状态的活动
       仍然是完全存活着的，系统也不愿意回收这种活动（因为它是可见的，回收可见的东西用户体验不好），只有
       在内存极低的情况下，系统才会考虑回收这种活动。

       3）停止状态：当一个活动不再处于栈顶位置，而且完全不可见时，就进入停止状态。系统仍然会为这种活动
       保存相应的状态和成员变量，但这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能
       会被系统回收。

       4）销毁状态：当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收这种状态的活动，从而
       保证手机的内存充足。

3 活动的生存期
      onCreate():在活动第一次被创建时候调用。在这个方法中完成活动的初始化操作，比如加载布局，绑定事件。

      onStart();在活动由不可见变为可见的时候调用。

      onResume():在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并处于运行状态。

      onPause();在系统准备去启动或者恢复另一个活动的时候调用。通常会在这个方法中将一些消耗CPU的资源释放
      掉，以及保存一些关键数据，但这个方法执行的速度一定要快，不然会影响到新的栈顶活动的使用。

      onStop():在活动完全不可见时调用。它和resume（）方法的主要区别在于，如果启动的新活动是一个对话框式
      的活动，那么onPause()方法会得到执行，而onstop（）方法并不会执行

      onDestory():在活动被销毁之前调用，之后活动的状将变成销毁状态。

      onRestart(): 在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。

      以上7个方法中除了onRestart()方法，其他都是两两相对的，从而有可以将活动分为3种生存期。

      完整生存期：活动在 oncreate()方法和onDestory()方法之间所经历的，就是完整生存期。一般情况下，一个活动
      会在oncreate()方法中完成各种初始化操作，而在onDestory()方法中完成释放内存的操作。

      可见生存期：活动在 onStart()和onStop()之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是
      可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在
      onStart()方法中对资源进行加载，而在 onStop()中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存

      前台生存期：活动在onResume()方法和 onPause()方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于
      运行状态的，此时的活动是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的活动，







